{"inputs": {"code": "package main\nimport (\n  \"net/http\"\n  \"io/ioutil\"\n)\n\nfunc fetch(url string) string {\n  resp, _ := http.Get(url)\n  body, _ := ioutil.ReadAll(resp.Body)\n  defer resp.Body.Close()\n  return string(body)\n}"}, "outputs": {"findings": [{"type": "missing_timeout", "line": 8, "description": "http.Get sem contexto ou timeout pode travar indefinidamente", "severity": "medium"}, {"type": "ignored_error", "line": 8, "description": "erro de http.Get ignorado", "severity": "high"}, {"type": "ignored_error", "line": 9, "description": "erro de ReadAll ignorado", "severity": "medium"}, {"type": "missing_status_check", "line": 9, "description": "não verifica status code antes de ler o corpo", "severity": "low"}], "summary": "Adicionar timeout via contexto, checar erros de http.Get e io.ReadAll e validar status code antes de ler o corpo."}, "metadata": {"topic": "http_client", "category": "robustness"}}
{"inputs": {"code": "package repo\n\nimport (\n  \"database/sql\"\n  \"fmt\"\n)\n\nfunc GetUser(db *sql.DB, username string) (int, error) {\n  query := fmt.Sprintf(\"SELECT id FROM users WHERE username = '%s'\", username)\n  row := db.QueryRow(query)\n  var id int\n  if err := row.Scan(&id); err != nil {\n    return 0, err\n  }\n  return id, nil\n}"}, "outputs": {"findings": [{"type": "sql_injection", "line": 10, "description": "query concatenada com input do usuário permite SQL injection, use parâmetros", "severity": "critical"}, {"type": "missing_timeout", "line": 11, "description": "QueryRow sem contexto com timeout", "severity": "medium"}], "summary": "Use parâmetros preparados em vez de Sprintf e rode a consulta com contexto e timeout."}, "metadata": {"topic": "database", "category": "security"}}
{"inputs": {"code": "package main\n\nimport \"database/sql\"\n\nfunc GetAllUsers(db *sql.DB) []User {\n  users := []User{}\n  ids := []int{1, 2, 3, 4, 5}\n  for _, id := range ids {\n    row := db.QueryRow(\"SELECT * FROM users WHERE id = ?\", id)\n    var u User\n    row.Scan(&u.ID, &u.Name)\n    users = append(users, u)\n  }\n  return users\n}"}, "outputs": {"findings": [{"type": "n_plus_1_query", "line": 9, "description": "Loop executa query individual por ID - deveria usar WHERE IN ou JOIN", "severity": "high"}, {"type": "missing_index", "line": 9, "description": "Se não houver índice em 'id', cada query será lenta", "severity": "medium"}, {"type": "ignored_error", "line": 10, "description": "Erro de Scan ignorado pode corromper dados", "severity": "medium"}], "summary": "Usar query única com WHERE IN ao invés de loop com queries individuais (N+1 problem)."}, "metadata": {"topic": "database", "category": "performance"}}
{"inputs": {"code": "package api\n\nimport (\n  \"context\"\n  \"time\"\n)\n\nfunc ProcessBatch(ctx context.Context, items []string) {\n  for _, item := range items {\n    time.Sleep(5 * time.Second)\n    result := heavyComputation(item)\n    saveToDatabase(result)\n  }\n}"}, "outputs": {"findings": [{"type": "blocking_operation", "line": 10, "description": "Sleep bloqueante - deveria processar em goroutines paralelas", "severity": "high"}, {"type": "no_context_check", "line": 10, "description": "Não verifica ctx.Done() - pode continuar processando após timeout", "severity": "medium"}, {"type": "sequential_processing", "line": 9, "description": "Processamento sequencial quando poderia ser paralelo", "severity": "high"}], "summary": "Usar worker pool com goroutines para processamento paralelo e respeitar context cancellation."}, "metadata": {"topic": "concurrency", "category": "performance"}}
{"inputs": {"code": "package main\n\nfunc calculate(a int, b int, c int, d int, e int, f int, g int) int {\n  var result int\n  result = a + b\n  result = result + c\n  result = result + d\n  result = result + e\n  result = result + f\n  result = result + g\n  if result > 100 {\n    result = result - 50\n  }\n  if result < 0 {\n    result = 0\n  }\n  return result\n}"}, "outputs": {"findings": [{"type": "too_many_parameters", "line": 3, "description": "Função com 7 parâmetros - difícil de usar e manter, use struct", "severity": "medium"}, {"type": "poor_naming", "line": 3, "description": "Nomes de variáveis genéricos (a, b, c) - sem significado", "severity": "medium"}, {"type": "code_duplication", "line": 5, "description": "Múltiplas linhas fazendo 'result = result + x' - poderia usar loop ou sum", "severity": "low"}], "summary": "Refatorar para aceitar slice ou struct com campos bem nomeados, usar loop para soma."}, "metadata": {"topic": "code_quality", "category": "maintainability"}}
{"inputs": {"code": "package utils\n\nfunc ProcessData(data string) string {\n  data = cleanData(data)\n  data = validateData(data)\n  data = transformData(data)\n  data = enrichData(data)\n  data = formatData(data)\n  return data\n}\n\nfunc cleanData(d string) string { return d }\nfunc validateData(d string) string { return d }\nfunc transformData(d string) string { return d }\nfunc enrichData(d string) string { return d }\nfunc formatData(d string) string { return d }"}, "outputs": {"findings": [{"type": "missing_error_handling", "line": 4, "description": "Nenhuma função retorna erro - validação deveria poder falhar", "severity": "high"}, {"type": "unclear_flow", "line": 3, "description": "Pipeline de transformações sem indicação clara de propósito", "severity": "medium"}, {"type": "stub_functions", "line": 13, "description": "Funções stub vazias - implementação incompleta", "severity": "high"}], "summary": "Adicionar tratamento de erros em cada etapa e implementar lógica real das funções."}, "metadata": {"topic": "code_quality", "category": "maintainability"}}
{"inputs": {"code": "package main\n\nimport \"os/exec\"\n\nfunc RunCommand(userInput string) string {\n  cmd := exec.Command(\"sh\", \"-c\", userInput)\n  output, _ := cmd.Output()\n  return string(output)\n}"}, "outputs": {"findings": [{"type": "command_injection", "line": 6, "description": "Executar comando shell com input não sanitizado permite command injection", "severity": "critical"}, {"type": "ignored_error", "line": 7, "description": "Erro de cmd.Output() ignorado pode esconder falhas", "severity": "medium"}], "summary": "NUNCA executar comandos shell com input do usuário. Se necessário, use whitelist de comandos permitidos."}, "metadata": {"topic": "command_execution", "category": "security"}}
{"inputs": {"code": "package main\n\nimport (\n  \"net/http\"\n  \"fmt\"\n)\n\nfunc handler(w http.ResponseWriter, r *http.Request) {\n  name := r.URL.Query().Get(\"name\")\n  fmt.Fprintf(w, \"<h1>Hello %s</h1>\", name)\n}"}, "outputs": {"findings": [{"type": "xss_vulnerability", "line": 10, "description": "Output não escapado permite XSS - use html/template", "severity": "critical"}, {"type": "missing_input_validation", "line": 9, "description": "Input não validado pode conter conteúdo malicioso", "severity": "high"}], "summary": "Usar html/template para escapar output automaticamente e validar input do usuário."}, "metadata": {"topic": "web", "category": "security"}}
{"inputs": {"code": "package cache\n\nimport \"sync\"\n\ntype Cache struct {\n  data map[string][]byte\n  mu   sync.Mutex\n}\n\nfunc (c *Cache) Get(key string) []byte {\n  c.mu.Lock()\n  defer c.mu.Unlock()\n  return c.data[key]\n}\n\nfunc (c *Cache) Set(key string, value []byte) {\n  c.mu.Lock()\n  c.data[key] = value\n  c.mu.Unlock()\n}"}, "outputs": {"findings": [{"type": "inefficient_locking", "line": 11, "description": "Mutex para leitura - deveria usar sync.RWMutex para permitir leituras concorrentes", "severity": "high"}, {"type": "unbounded_growth", "line": 18, "description": "Map cresce indefinidamente - sem TTL ou eviction policy", "severity": "medium"}, {"type": "missing_defer", "line": 18, "description": "Set não usa defer unlock - se panic acontecer, deadlock", "severity": "high"}], "summary": "Usar RWMutex, adicionar defer em Set e implementar cache eviction policy."}, "metadata": {"topic": "concurrency", "category": "performance"}}
{"inputs": {"code": "package main\n\nfunc CalculateTotal(items []Item) float64 {\n  var total float64\n  for i := 0; i < len(items); i++ {\n    total = total + items[i].Price\n    total = total + items[i].Tax\n    total = total - items[i].Discount\n  }\n  if total < 0 {\n    total = 0\n  }\n  return total\n}"}, "outputs": {"findings": [{"type": "verbose_loop", "line": 5, "description": "Loop tradicional ao invés de range - menos idiomático em Go", "severity": "low"}, {"type": "code_duplication", "line": 6, "description": "Múltiplas atribuições 'total = total + x' - poderia usar operador +=", "severity": "low"}, {"type": "magic_logic", "line": 10, "description": "Lógica de 'total negativo vira 0' sem explicação - adicionar comentário", "severity": "medium"}], "summary": "Usar range loop, operador += e adicionar comentário explicando regra de negócio."}, "metadata": {"topic": "code_quality", "category": "maintainability"}}
{"inputs": {"code": "package main\n\nfunc Add(a, b int) int {\n  return a + b\n}"}, "outputs": {"findings": [], "summary": "Função simples sem problemas aparentes"}, "metadata": {"topic": "simple_function", "category": "testing"}}
{"inputs": {"code": "package main\n\nfunc Multiply(x, y int) int {\n  return x * y\n}"}, "outputs": {"findings": [], "summary": "Função de multiplicação correta"}, "metadata": {"topic": "simple_function", "category": "testing"}}
{"inputs": {"code": "package main\n\nfunc Subtract(a, b int) int {\n  return a - b\n}"}, "outputs": {"findings": [], "summary": "Subtração implementada corretamente"}, "metadata": {"topic": "simple_function", "category": "testing"}}
{"inputs": {"code": "package main\n\nfunc Divide(a, b int) int {\n  return a / b\n}"}, "outputs": {"findings": [{"type": "division_by_zero", "line": 4, "description": "Não verifica divisão por zero", "severity": "high"}], "summary": "Adicionar verificação de divisão por zero"}, "metadata": {"topic": "division_by_zero", "category": "testing"}}
{"inputs": {"code": "package main\n\nfunc Simple() {\n  fmt.Println(\"hello\")\n}"}, "outputs": {"findings": [{"type": "import_missing", "line": 4, "description": "Falta importar pacote fmt", "severity": "high"}], "summary": "Adicionar import do pacote fmt"}, "metadata": {"topic": "import_missing", "category": "testing"}}
{"inputs": {"code": "package main\n\nfunc Hello() string {\n  return \"world\"\n}"}, "outputs": {"findings": [], "summary": "Função simples que retorna string"}, "metadata": {"topic": "simple_function", "category": "testing"}}
{"inputs": {"code": "package main\n\nimport \"fmt\"\n\nfunc Print() {\n  fmt.Println(\"test\")\n}"}, "outputs": {"findings": [], "summary": "Função de print básica"}, "metadata": {"topic": "simple_function", "category": "testing"}}
{"inputs": {"code": "package main\n\nfunc Max(a, b int) int {\n  if a > b {\n    return a\n  }\n  return b\n}"}, "outputs": {"findings": [], "summary": "Função max implementada corretamente"}, "metadata": {"topic": "simple_function", "category": "testing"}}
