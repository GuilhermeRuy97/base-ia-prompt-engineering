{"inputs": {"code": "package main\nimport (\n  \"net/http\"\n  \"io/ioutil\"\n)\n\nfunc fetch(url string) string {\n  resp, _ := http.Get(url)\n  body, _ := ioutil.ReadAll(resp.Body)\n  defer resp.Body.Close()\n  return string(body)\n}"}, "outputs": {"findings": [{"type": "missing_timeout", "severity": "medium"}, {"type": "ignored_error", "severity": "high"}, {"type": "ignored_error", "severity": "medium"}, {"type": "missing_status_check", "severity": "low"}], "summary": "Adicionar timeout via contexto, checar erros de http.Get e io.ReadAll e validar status code antes de ler o corpo."}, "metadata": {"topic": "http_client", "category": "robustness"}}
{"inputs": {"code": "package repo\n\nimport (\n  \"database/sql\"\n  \"fmt\"\n)\n\nfunc GetUser(db *sql.DB, username string) (int, error) {\n  query := fmt.Sprintf(\"SELECT id FROM users WHERE username = '%s'\", username)\n  row := db.QueryRow(query)\n  var id int\n  if err := row.Scan(&id); err != nil {\n    return 0, err\n  }\n  return id, nil\n}"}, "outputs": {"findings": [{"type": "sql_injection", "severity": "critical"}, {"type": "missing_timeout", "severity": "medium"}], "summary": "Use parâmetros preparados em vez de Sprintf e rode a consulta com contexto e timeout."}, "metadata": {"topic": "database", "category": "security"}}
{"inputs": {"code": "package main\n\nimport \"database/sql\"\n\nfunc GetAllUsers(db *sql.DB) []User {\n  users := []User{}\n  ids := []int{1, 2, 3, 4, 5}\n  for _, id := range ids {\n    row := db.QueryRow(\"SELECT * FROM users WHERE id = ?\", id)\n    var u User\n    row.Scan(&u.ID, &u.Name)\n    users = append(users, u)\n  }\n  return users\n}"}, "outputs": {"findings": [{"type": "n_plus_1_query", "severity": "high"}, {"type": "missing_index", "severity": "medium"}, {"type": "ignored_error", "severity": "medium"}], "summary": "Usar query única com WHERE IN ao invés de loop com queries individuais (N+1 problem)."}, "metadata": {"topic": "database", "category": "performance"}}
{"inputs": {"code": "package api\n\nimport (\n  \"context\"\n  \"time\"\n)\n\nfunc ProcessBatch(ctx context.Context, items []string) {\n  for _, item := range items {\n    time.Sleep(5 * time.Second)\n    result := heavyComputation(item)\n    saveToDatabase(result)\n  }\n}"}, "outputs": {"findings": [{"type": "blocking_operation", "severity": "high"}, {"type": "no_context_check", "severity": "medium"}, {"type": "sequential_processing", "severity": "high"}], "summary": "Usar worker pool com goroutines para processamento paralelo e respeitar context cancellation."}, "metadata": {"topic": "concurrency", "category": "performance"}}
{"inputs": {"code": "package main\n\nfunc calculate(a int, b int, c int, d int, e int, f int, g int) int {\n  var result int\n  result = a + b\n  result = result + c\n  result = result + d\n  result = result + e\n  result = result + f\n  result = result + g\n  if result > 100 {\n    result = result - 50\n  }\n  if result < 0 {\n    result = 0\n  }\n  return result\n}"}, "outputs": {"findings": [{"type": "too_many_parameters", "severity": "medium"}, {"type": "poor_naming", "severity": "medium"}, {"type": "code_duplication", "severity": "low"}], "summary": "Refatorar para aceitar slice ou struct com campos bem nomeados, usar loop para soma."}, "metadata": {"topic": "code_quality", "category": "maintainability"}}
{"inputs": {"code": "package utils\n\nfunc ProcessData(data string) string {\n  data = cleanData(data)\n  data = validateData(data)\n  data = transformData(data)\n  data = enrichData(data)\n  data = formatData(data)\n  return data\n}\n\nfunc cleanData(d string) string { return d }\nfunc validateData(d string) string { return d }\nfunc transformData(d string) string { return d }\nfunc enrichData(d string) string { return d }\nfunc formatData(d string) string { return d }"}, "outputs": {"findings": [{"type": "missing_error_handling", "severity": "high"}, {"type": "unclear_flow", "severity": "medium"}, {"type": "stub_functions", "severity": "high"}], "summary": "Adicionar tratamento de erros em cada etapa e implementar lógica real das funções."}, "metadata": {"topic": "code_quality", "category": "maintainability"}}
{"inputs": {"code": "package main\n\nimport \"os/exec\"\n\nfunc RunCommand(userInput string) string {\n  cmd := exec.Command(\"sh\", \"-c\", userInput)\n  output, _ := cmd.Output()\n  return string(output)\n}"}, "outputs": {"findings": [{"type": "command_injection", "severity": "critical"}, {"type": "ignored_error", "severity": "medium"}], "summary": "NUNCA executar comandos shell com input do usuário. Se necessário, use whitelist de comandos permitidos."}, "metadata": {"topic": "command_execution", "category": "security"}}
{"inputs": {"code": "package main\n\nimport (\n  \"net/http\"\n  \"fmt\"\n)\n\nfunc handler(w http.ResponseWriter, r *http.Request) {\n  name := r.URL.Query().Get(\"name\")\n  fmt.Fprintf(w, \"<h1>Hello %s</h1>\", name)\n}"}, "outputs": {"findings": [{"type": "xss_vulnerability", "severity": "critical"}, {"type": "missing_input_validation", "severity": "high"}], "summary": "Usar html/template para escapar output automaticamente e validar input do usuário."}, "metadata": {"topic": "web", "category": "security"}}
{"inputs": {"code": "package cache\n\nimport \"sync\"\n\ntype Cache struct {\n  data map[string][]byte\n  mu   sync.Mutex\n}\n\nfunc (c *Cache) Get(key string) []byte {\n  c.mu.Lock()\n  defer c.mu.Unlock()\n  return c.data[key]\n}\n\nfunc (c *Cache) Set(key string, value []byte) {\n  c.mu.Lock()\n  c.data[key] = value\n  c.mu.Unlock()\n}"}, "outputs": {"findings": [{"type": "inefficient_locking", "severity": "high"}, {"type": "unbounded_growth", "severity": "medium"}, {"type": "missing_defer", "severity": "high"}], "summary": "Usar RWMutex, adicionar defer em Set e implementar cache eviction policy."}, "metadata": {"topic": "concurrency", "category": "performance"}}
{"inputs": {"code": "package main\n\nfunc CalculateTotal(items []Item) float64 {\n  var total float64\n  for i := 0; i < len(items); i++ {\n    total = total + items[i].Price\n    total = total + items[i].Tax\n    total = total - items[i].Discount\n  }\n  if total < 0 {\n    total = 0\n  }\n  return total\n}"}, "outputs": {"findings": [{"type": "verbose_loop", "severity": "low"}, {"type": "code_duplication", "severity": "low"}, {"type": "magic_logic", "severity": "medium"}], "summary": "Usar range loop, operador += e adicionar comentário explicando regra de negócio."}, "metadata": {"topic": "code_quality", "category": "maintainability"}}
{"inputs": {"code": "package main\n\nfunc Add(a, b int) int {\n  return a + b\n}"}, "outputs": {"findings": [], "summary": "Função simples sem problemas aparentes"}, "metadata": {"topic": "simple_function", "category": "testing"}}
{"inputs": {"code": "package main\n\nfunc Multiply(x, y int) int {\n  return x * y\n}"}, "outputs": {"findings": [], "summary": "Função de multiplicação correta"}, "metadata": {"topic": "simple_function", "category": "testing"}}
{"inputs": {"code": "package main\n\nfunc Subtract(a, b int) int {\n  return a - b\n}"}, "outputs": {"findings": [], "summary": "Subtração implementada corretamente"}, "metadata": {"topic": "simple_function", "category": "testing"}}
{"inputs": {"code": "package main\n\nfunc Divide(a, b int) int {\n  return a / b\n}"}, "outputs": {"findings": [{"type": "division_by_zero", "severity": "high"}], "summary": "Adicionar verificação de divisão por zero"}, "metadata": {"topic": "division_by_zero", "category": "testing"}}
{"inputs": {"code": "package main\n\nfunc Simple() {\n  fmt.Println(\"hello\")\n}"}, "outputs": {"findings": [{"type": "import_missing", "severity": "high"}], "summary": "Adicionar import do pacote fmt"}, "metadata": {"topic": "import_missing", "category": "testing"}}
{"inputs": {"code": "package main\n\nfunc Hello() string {\n  return \"world\"\n}"}, "outputs": {"findings": [], "summary": "Função simples que retorna string"}, "metadata": {"topic": "simple_function", "category": "testing"}}
{"inputs": {"code": "package main\n\nimport \"fmt\"\n\nfunc Print() {\n  fmt.Println(\"test\")\n}"}, "outputs": {"findings": [], "summary": "Função de print básica"}, "metadata": {"topic": "simple_function", "category": "testing"}}
{"inputs": {"code": "package main\n\nfunc Max(a, b int) int {\n  if a > b {\n    return a\n  }\n  return b\n}"}, "outputs": {"findings": [], "summary": "Função max implementada corretamente"}, "metadata": {"topic": "simple_function", "category": "testing"}}
